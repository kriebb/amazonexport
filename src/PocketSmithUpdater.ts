import fs from 'fs';
import { PocketSmithClient, OrderItem , TransactionAccount, Transaction, PocketSmithApiError } from './PocketSmithClient';

// Extend the OrderItem interface to include metadata

import { parse as parseCsv } from 'papaparse';
import dotenv from 'dotenv';
// Add this to your PocketSmithUpdater.ts file
// Load environment variables
dotenv.config();

/**
 * CSV record structure (from your existing GenerateCSVToshlStrategy)
 */
interface CsvRecord {
    'Date': string;
    'Merchant': string;
    'Category': string;
    'Amount': string;
    'Currency': string;
    'Quantity': string;
    'Note': string;
    'Order Number': string;
    'Order Total': string;
}

/**
 * Options for the PocketSmith updater
 */
interface PocketSmithUpdaterOptions {
    apiKey?: string;
    transactionAccountId?: string;
    dryRun?: boolean;
    splitExistingTransactions?: boolean;
}

/**
 * A standalone class to sync Amazon order data from CSV to PocketSmith
 */
export class PocketSmithUpdater {
    private client: PocketSmithClient;
    private transactionAccountId: string;
    private dryRun: boolean;
    private splitExistingTransactions: boolean;

    /**
     * Create a new PocketSmith updater
     * @param options Configuration options
     */
    constructor(options: PocketSmithUpdaterOptions = {}) {
        // Initialize PocketSmith client
        this.client = new PocketSmithClient({
            apiKey: options.apiKey || process.env.POCKETSMITH_API_KEY || '',
        });

        // Set transaction account ID
        this.transactionAccountId = options.transactionAccountId ||
            process.env.POCKETSMITH_TRANSACTION_ACCOUNT_ID || '';

        // Set other options
        this.dryRun = options.dryRun ?? (process.env.POCKETSMITH_DRY_RUN === 'true');
        this.splitExistingTransactions = options.splitExistingTransactions ??
            (process.env.POCKETSMITH_SPLIT_TRANSACTIONS === 'true');
    }

    /**
     * Process a CSV file and sync with PocketSmith
     * @param csvFilePath Path to the CSV file generated by your existing strategy
     */
    async processCsvFile(csvFilePath: string): Promise<void> {
        try {
            console.log(`Processing CSV file: ${csvFilePath}`);

            // First validate that we can authenticate with PocketSmith
            const isAuthenticated = await this.client.validateAuthentication();
            if (!isAuthenticated) {
                console.error('Cannot proceed with PocketSmith integration due to authentication failure.');
                return;
            }

            // Check if file exists
            if (!fs.existsSync(csvFilePath)) {
                console.error(`CSV file not found: ${csvFilePath}`);
                return;
            }

            // Read and parse CSV file
            const csvContent = fs.readFileSync(csvFilePath, 'utf8');
            const parseResult = parseCsv<CsvRecord>(csvContent, {
                header: true,
                skipEmptyLines: true
            });

            if (parseResult.errors.length > 0) {
                console.error('CSV parsing errors:', parseResult.errors);
                return;
            }

            console.log(`Parsed ${parseResult.data.length} records from CSV`);

            // Convert CSV records to OrderItems
            const orderItems = this.convertCsvRecordsToOrderItems(parseResult.data);
            console.log(`Converted to ${orderItems.length} order items`);

            // If we want to split existing transactions
            if (this.splitExistingTransactions) {
                await this.splitExistingAmazonTransactions(orderItems);
            } else {
                // Otherwise, use the specified transaction account ID
                if (!this.transactionAccountId) {
                    // Try to find the most recent Amazon transaction's account
                    const mostRecent = await this.findMostRecentAmazonTransaction();

                    if (mostRecent) {
                        console.log(`Using most recent Amazon transaction's account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);
                        await this.syncWithPocketSmith(orderItems, mostRecent.transactionAccount.id);
                    } else {
                        console.error('No Amazon transactions found and no transaction account ID specified in .env file.');
                        console.error('Please set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.');
                        return;
                    }
                } else {
                    console.log(`Using specified default transaction account ID: ${this.transactionAccountId}`);
                    await this.syncWithPocketSmith(orderItems, this.transactionAccountId);
                }
            }

            console.log('PocketSmith processing completed successfully.');

        } catch (error) {
            if (error instanceof PocketSmithApiError) {
                // API errors are already properly formatted by the client
                console.error('Error processing CSV file:', error.message);
            } else {
                console.error('Error processing CSV file:', error instanceof Error ? error.message : String(error));
            }
        }
    }

    /**
     * Convert CSV records to OrderItems for PocketSmith API
     * @param records CSV records from your existing strategy
     * @returns OrderItems ready for PocketSmith API
     */
    private convertCsvRecordsToOrderItems(records: CsvRecord[]): OrderItem[] {
        return records.map(record => ({
            name: `${record.Merchant} - ${record.Category}`,
            description: record.Note,
            amount: parseFloat(record.Amount),
            date: record.Date,
            category: record.Category
        }));
    }

    /**
     * List all accounts and transaction accounts
     */
    async listAllAccounts(): Promise<void> {
        try {
            // First validate that we can authenticate with PocketSmith
            const isAuthenticated = await this.client.validateAuthentication();
            if (!isAuthenticated) {
                console.error('Cannot list accounts due to authentication failure.');
                return;
            }

            console.log("\n=== PocketSmith Accounts ===");

            const accounts = await this.client.getAllAccounts();
            console.log(`Found ${accounts.length} accounts:`);

            for (const account of accounts) {
                console.log(`\nðŸ“‚ Account: "${account.institution.title}" (ID: ${account.id})`);

                console.log('  Transaction Accounts:');
                for (const transactionAccount of account.transaction_accounts) {
                    console.log(`  - ${transactionAccount.name} (ID: ${transactionAccount.id}, Type: ${transactionAccount.type})`);
                }
            }

            console.log("\nTo use a specific account, set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.");
            console.log("===========================\n");

        } catch (error) {
            if (error instanceof PocketSmithApiError) {
                console.error('Error listing accounts:', error.message);
            } else {
                console.error('Error listing accounts:', error instanceof Error ? error.message : String(error));
            }
        }
    }

    /**
     * Find the most recent Amazon transaction among all accounts
     */
    async findMostRecentAmazonTransaction(): Promise<{ transaction: Transaction, transactionAccount: TransactionAccount } | null> {
        try {
            const amazonTransactions = await this.client.findAllAmazonTransactions();

            if (amazonTransactions.length === 0) {
                console.log("No Amazon transactions found");
                return null;
            }

            console.log(`Found ${amazonTransactions.length} Amazon transactions across all accounts`);

            // Sort by date descending to get the most recent
            const sortedTransactions = amazonTransactions.sort((a, b) => {
                return new Date(b.transaction.date).getTime() - new Date(a.transaction.date).getTime();
            });

            const mostRecent = sortedTransactions[0];

            console.log(`Most recent Amazon transaction found: ${mostRecent.transaction.payee} - $${mostRecent.transaction.amount} (${mostRecent.transaction.date})`);
            console.log(`In account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);

            return mostRecent;
        } catch (error) {
            console.error('Error finding recent Amazon transactions:',
                error instanceof Error ? error.message : String(error));
            return null;
        }
    }

 /**
 * Find matching Amazon transactions for JSON-based order items
 * Updated to store all order data for reporting
 */
async findMatchingAmazonTransactions(orderItems: OrderItem[]): Promise<Map<number, {transactions: Transaction[], transactionAccount: TransactionAccount}>> {
    try {
      // Get the earliest date from the order items
      const startDate = this.getEarliestDate(orderItems);
      
      // Calculate the end date - use today's date
      const endDate = new Date().toISOString().split('T')[0];
      
      console.log(`Finding Amazon transactions between ${startDate} and ${endDate}`);
      
      // Find all Amazon transactions since that date
      const amazonTransactions = await this.client.findAllAmazonTransactions(startDate, endDate);
      
      if (amazonTransactions.length === 0) {
        console.log(`No Amazon transactions found since ${startDate}`);
        return new Map();
      }
      
      console.log(`Found ${amazonTransactions.length} Amazon transactions across all accounts since ${startDate}`);
      
      // Add this line to print detailed debug info
      this.printDebugInfo(amazonTransactions, orderItems);
      
      // Group order items by order date and order ID
      // This ensures items from the same order stay together
      const ordersByDateAndId = new Map<string, OrderItem[]>();
      
      for (const item of orderItems) {
        // Get metadata if available
        const metadata = (item as any).metadata || {};
        const orderId = metadata.orderId || 'unknown';
        const orderDate = item.date;
        const orderTotal = metadata.orderTotal || 0;
        
        // Create a unique key for each order: date_orderId_total
        const key = `${orderDate}_${orderId}_${orderTotal.toFixed(2)}`;
        
        if (!ordersByDateAndId.has(key)) {
          ordersByDateAndId.set(key, []);
        }
        
        ordersByDateAndId.get(key)!.push(item);
      }
      
      // Calculate total for each order and store with more complete information
      const orderTotals = new Map<string, {date: string, orderId: string, total: number, items: OrderItem[]}>();
      
      for (const [key, items] of ordersByDateAndId.entries()) {
        const [date, orderId, totalStr] = key.split('_');
        const orderTotal = parseFloat(totalStr);
        
        // Use the key with just date and order ID
        const simpleKey = `${date}_${orderId}`;
        
        orderTotals.set(simpleKey, {
          date,
          orderId,
          total: orderTotal,
          items
        });
      }
      
      console.log(`Grouped ${orderItems.length} order items into ${orderTotals.size} unique orders`);
      
      // Now find matching transactions based on date and total amount
      const matchingTransactions: {transaction: Transaction, transactionAccount: TransactionAccount, matchKey: string}[] = [];
      
      for (const txItem of amazonTransactions) {
        const tx = txItem.transaction;
        const txDate = tx.date;
        const txAmount = Math.abs(parseFloat(tx.amount.toString()));
        
        // Skip if transaction doesn't have a valid amount
        if (isNaN(txAmount)) continue;
        
        let bestMatch: {key: string, diff: number} | null = null;
        
        // Find the best matching order for this transaction
        for (const [key, orderInfo] of orderTotals.entries()) {
          // Check if the dates match
          if (orderInfo.date === txDate) {
            // Calculate absolute difference between transaction amount and order total
            const amountDiff = Math.abs(txAmount - orderInfo.total);
            
            // Calculate percentage difference
            const percentDiff = orderInfo.total > 0 ? (amountDiff / orderInfo.total) * 100 : 100;
            
            // If within tolerance or better than previous best match
            if (percentDiff <= 5 && (!bestMatch || percentDiff < bestMatch.diff)) {
              bestMatch = {
                key,
                diff: percentDiff
              };
            }
          }
        }
        
        // If we found a match, add it
        if (bestMatch) {
          const orderInfo = orderTotals.get(bestMatch.key)!;
          
          console.log(`Transaction match found! Date: ${txDate}, Bank amount: ${txAmount.toFixed(2)}, Order total: ${orderInfo.total.toFixed(2)}, Diff: ${bestMatch.diff.toFixed(2)}%`);
          
          matchingTransactions.push({
            transaction: tx,
            transactionAccount: txItem.transactionAccount,
            matchKey: bestMatch.key
          });
          
          // No longer remove the matched order - keep it for reporting
          // orderTotals.delete(bestMatch.key);
        }
      }
      
      console.log(`Found ${matchingTransactions.length} transactions with matching dates and total amounts`);
      
      // Generate a report of matched and unmatched orders
      this.generateOrderMatchingReport(orderTotals, matchingTransactions);
      
      // Group matched transactions by transaction account ID
      const result = new Map<number, {transactions: Transaction[], transactionAccount: TransactionAccount}>();
      
      for (const item of matchingTransactions) {
        const accountId = item.transactionAccount.id;
        
        if (!result.has(accountId)) {
          result.set(accountId, {
            transactions: [],
            transactionAccount: item.transactionAccount
          });
        }
        
        result.get(accountId)!.transactions.push(item.transaction);
        
        // Debug output: Show order details for this transaction
        const matchingOrderItems = item.matchKey.split('_');
        const date = matchingOrderItems[0];
        const orderId = matchingOrderItems[1];
        
        console.log(`Transaction ${item.transaction.id} (${item.transaction.payee.substring(0, 30)}...) matches order ${orderId} on ${date}`);
      }
      
      // Log the findings
      for (const [accountId, data] of result.entries()) {
        console.log(`Account ${data.transactionAccount.name} (ID: ${accountId}) has ${data.transactions.length} matching transactions`);
      }
      
      return result;
    } catch (error) {
      console.error('Error finding matching Amazon transactions:', 
        error instanceof Error ? error.message : String(error));
      return new Map();
    }
  }  

    /**
     * Creates a matching key from date and amount
     * Format: "YYYY-MM-DD_XX.XX"
     */
    private createMatchingKey(date: string, amount: number): string {
        return `${date}_${amount.toFixed(2)}`;
    }

    /**
 * When processing a specific matched transaction, get the order items that match it
 * This uses the order ID and date to find items from the same order
 */
private getMatchingOrderItems(transaction: Transaction, orderItems: OrderItem[]): OrderItem[] {
    const txDate = transaction.date;
    
    // Group items by order ID
    const itemsByOrder = new Map<string, OrderItem[]>();
    
    for (const item of orderItems) {
      // Skip items that don't match the transaction date
      if (item.date !== txDate) continue;
      
      // Get order ID from metadata
      const metadata = (item as any).metadata || {};
      const orderId = metadata.orderId || 'unknown';
      
      if (!itemsByOrder.has(orderId)) {
        itemsByOrder.set(orderId, []);
      }
      
      itemsByOrder.get(orderId)!.push(item);
    }
    
    // Find best matching order by comparing totals
    let bestMatchItems: OrderItem[] = [];
    let bestMatchDiff = Infinity;
    
    const txAmount = Math.abs(parseFloat(transaction.amount.toString()));
    
    for (const [orderId, items] of itemsByOrder.entries()) {
      // Calculate total for this order
      const orderTotal = items.reduce((sum, item) => sum + parseFloat(item.amount.toString()), 0);
      
      // Calculate difference
      const diff = Math.abs(txAmount - orderTotal);
      
      // If this is better than our previous best match
      if (diff < bestMatchDiff) {
        bestMatchDiff = diff;
        bestMatchItems = items;
      }
    }
    
    return bestMatchItems;
  }
    /**
   * Split existing Amazon transactions into individual items
   * @param orderItems Order items to create
   */
    async splitExistingAmazonTransactions(orderItems: OrderItem[]): Promise<void> {
        console.log("Looking for existing Amazon transactions to split...");

        try {
            // Find matching Amazon transactions
            const matchingAccounts = await this.findMatchingAmazonTransactions(orderItems);

            if (matchingAccounts.size === 0) {
                console.log("No matching transactions found. Will use default transaction account instead.");

                if (!this.transactionAccountId) {
                    // Try to find the most recent Amazon transaction's account
                    const mostRecent = await this.findMostRecentAmazonTransaction();

                    if (mostRecent) {
                        console.log(`Using most recent Amazon transaction's account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);
                        await this.syncWithPocketSmith(orderItems, mostRecent.transactionAccount.id);
                    } else {
                        console.error('No Amazon transactions found and no transaction account ID specified in .env file.');
                        console.error('Please set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.');
                    }
                } else {
                    console.log(`Using specified default transaction account ID: ${this.transactionAccountId}`);
                    await this.syncWithPocketSmith(orderItems, this.transactionAccountId);
                }

                return;
            }

            // Split transactions in each matching account
            let totalSplit = 0;
            let totalCreated = 0;

            for (const [accountId, data] of matchingAccounts.entries()) {
                const { transactions, transactionAccount } = data;

                console.log(`Processing ${transactions.length} transactions in account ${transactionAccount.name}...`);

                for (const transaction of transactions) {
                    // Find matching order items for this transaction
                    const matchingItems = this.getMatchingOrderItems(transaction, orderItems);

                    if (matchingItems.length === 0) {
                        console.log(`No matching items found for transaction ${transaction.id} (${transaction.date}, ${transaction.amount}), skipping`);
                        continue;
                    }

                    console.log(`Splitting transaction ${transaction.id} (${transaction.payee}) into ${matchingItems.length} items`);

                    // Split the transaction
                    const result = await this.client.splitAmazonTransaction(
                        transaction,
                        transactionAccount,
                        matchingItems,
                        { dryRun: this.dryRun }
                    );

                    totalSplit += result.deleted;
                    totalCreated += result.created;
                }
            }

            if (this.dryRun) {
                console.log(`DRY RUN: Would have split ${totalSplit} transactions into ${totalCreated} items`);
            } else {
                console.log(`Successfully split ${totalSplit} transactions into ${totalCreated} items`);
            }
        } catch (error) {
            console.error('Error splitting Amazon transactions:',
                error instanceof Error ? error.message : String(error));
        }
    }

    /**
     * Group order items by date
     * @param items Order items to group
     * @returns Map of dates to lists of order items
     */
    private groupOrderItemsByDate(items: OrderItem[]): Map<string, OrderItem[]> {
        const result = new Map<string, OrderItem[]>();

        for (const item of items) {
            if (!result.has(item.date)) {
                result.set(item.date, []);
            }

            result.get(item.date)!.push(item);
        }

        return result;
    }

    /**
     * Sync order items with PocketSmith
     * @param items Order items to sync
     */
    private async syncWithPocketSmith(items: OrderItem[], transactionAccountId: string | number): Promise<void> {
        try {
            console.log(`Syncing ${items.length} order items with PocketSmith account ${transactionAccountId}...`);

            // Calculate date range from items
            const startDate = this.getEarliestDate(items);
            const today = new Date().toISOString().split('T')[0];

            // Use the PocketSmith client to process items
            const result = await this.client.processAmazonOrderItems(
                items,
                transactionAccountId,
                {
                    deleteExisting: true,
                    searchStartDate: startDate,
                    searchEndDate: today, // Always provide an end date
                    dryRun: this.dryRun
                }
            );

            if (this.dryRun) {
                console.log(`DRY RUN: Would have deleted ${result.deleted} transactions and created ${result.created} transactions`);
            } else {
                console.log(`Successfully deleted ${result.deleted} transactions and created ${result.created} transactions in PocketSmith`);
            }
        } catch (error) {
            console.error('Error syncing with PocketSmith:',
                error instanceof Error ? error.message : String(error));
            throw error; // Re-throw to be handled by the caller
        }
    }

    /**
     * Get the earliest date from a list of items
     * @param items Order items
     * @returns ISO date string
     */
    private getEarliestDate(items: OrderItem[]): string {
        if (items.length === 0) return new Date().toISOString().split('T')[0];

        const dates = items.map(item => new Date(item.date));
        const earliestDate = new Date(Math.min(...dates.map(d => d.getTime())));

        // Subtract 7 days to account for potential timing differences
        earliestDate.setDate(earliestDate.getDate() - 7);

        return earliestDate.toISOString().split('T')[0];
    }
    /**
     * Get the latest date from a list of items
     * @param items Order items
     * @returns ISO date string
     */
    private getLatestDate(items: OrderItem[]): string {
        if (items.length === 0) return new Date().toISOString().split('T')[0];

        const dates = items.map(item => new Date(item.date));
        const latestDate = new Date(Math.max(...dates.map(d => d.getTime())));

        // Add 7 days to account for potential timing differences
        latestDate.setDate(latestDate.getDate() + 7);

        return latestDate.toISOString().split('T')[0];
    }


    /**
   * Print detailed debug information about transactions and orders
   * @param amazonTransactions All Amazon transactions found
   * @param orderItems All order items being processed
   */
    private printDebugInfo(
        amazonTransactions: { transaction: Transaction, transactionAccount: TransactionAccount }[],
        orderItems: OrderItem[]
    ): void {
        console.log("\n===== DEBUG: TRANSACTION MATCHING DETAILS =====");

        // 1. Print all Amazon transactions found with date and amount
        console.log("\nALL AMAZON TRANSACTIONS FOUND:");
        amazonTransactions.forEach((txItem, index) => {
            const tx = txItem.transaction;
            console.log(`${index + 1}. Account: ${txItem.transactionAccount.name} | Date: ${tx.date} | Amount: ${tx.amount.toFixed(2)} | ID: ${tx.id}`);
            console.log(`   Payee: ${tx.payee.substring(0, 70)}...`);
        });

        // 2. Print all order items with date and amount
        console.log("\nALL ORDER ITEMS BEING PROCESSED:");
        orderItems.forEach((item, index) => {
            const amount = parseFloat(item.amount.toString());
            console.log(`${index + 1}. Date: ${item.date} | Amount: ${amount.toFixed(2)} | ${item.name.substring(0, 50)}...`);
        });

        // 3. Group order items by date to detect multiple orders on same day
        const ordersByDate = new Map<string, OrderItem[]>();
        for (const item of orderItems) {
            if (!ordersByDate.has(item.date)) {
                ordersByDate.set(item.date, []);
            }
            ordersByDate.get(item.date)!.push(item);
        }

        console.log("\nORDER ITEMS GROUPED BY DATE:");
        for (const [date, items] of ordersByDate.entries()) {
            const totalAmount = items.reduce((sum, item) => {
                const amount = parseFloat(item.amount.toString());
                return sum + (isNaN(amount) ? 0 : amount);
            }, 0);

            console.log(`Date: ${date} | Items: ${items.length} | Total: ${totalAmount.toFixed(2)}`);

            // If more than one item on this date, show the breakdown
            if (items.length > 1) {
                console.log(`  Breakdown:`);
                items.forEach((item, idx) => {
                    const amount = parseFloat(item.amount.toString());
                    console.log(`  ${idx + 1}. Amount: ${isNaN(amount) ? 'N/A' : amount.toFixed(2)} | ${item.name.substring(0, 40)}...`);
                });
            }
        }

        console.log("\n===== END DEBUG INFO =====\n");
    }

    /**
 * Process Amazon orders from a JSON file
 * @param jsonFilePath Path to the JSON file containing Amazon orders
 */
async processJsonFile(jsonFilePath: string): Promise<void> {
    try {
      console.log(`Processing JSON file: ${jsonFilePath}`);
      
      // First validate that we can authenticate with PocketSmith
      const isAuthenticated = await this.client.validateAuthentication();
      if (!isAuthenticated) {
        console.error('Cannot proceed with PocketSmith integration due to authentication failure.');
        return;
      }
      
      // Check if file exists
      if (!fs.existsSync(jsonFilePath)) {
        console.error(`JSON file not found: ${jsonFilePath}`);
        return;
      }
      
      // Read and parse JSON file
      const jsonContent = fs.readFileSync(jsonFilePath, 'utf8');
      const amazonOrders = JSON.parse(jsonContent);
      
      console.log(`Parsed ${amazonOrders.length} orders from JSON`);
      
      // Convert JSON orders to OrderItems
      const orderItems = this.convertJsonOrdersToOrderItems(amazonOrders);
      console.log(`Converted to ${orderItems.length} order items`);
      
      // If we want to split existing transactions
      if (this.splitExistingTransactions) {
        await this.splitExistingAmazonTransactions(orderItems);
      } else {
        // Otherwise, use the specified transaction account ID
        if (!this.transactionAccountId) {
          // Try to find the most recent Amazon transaction's account
          const mostRecent = await this.findMostRecentAmazonTransaction();
          
          if (mostRecent) {
            console.log(`Using most recent Amazon transaction's account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);
            await this.syncWithPocketSmith(orderItems, mostRecent.transactionAccount.id);
          } else {
            console.error('No Amazon transactions found and no transaction account ID specified in .env file.');
            console.error('Please set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.');
            return;
          }
        } else {
          console.log(`Using specified default transaction account ID: ${this.transactionAccountId}`);
          await this.syncWithPocketSmith(orderItems, this.transactionAccountId);
        }
      }
      
      console.log('PocketSmith processing completed successfully.');
      
    } catch (error) {
      console.error('Error processing JSON file:', error instanceof Error ? error.message : String(error));
    }
  }

  
/**
 * Convert Amazon JSON orders to OrderItems for PocketSmith API
 * @param amazonOrders Orders from the JSON file
 * @returns OrderItems ready for PocketSmith API
 */
private convertJsonOrdersToOrderItems(amazonOrders: any[]): OrderItem[] {
    const orderItems: OrderItem[] = [];
    
    // Process each order
    for (const order of amazonOrders) {
      // Skip orders without items
      if (!order.items || order.items.length === 0) continue;
      
      // Parse order date
      const orderDate = this.formatDate(order.orderPlacedDate);
      
      // Get order ID for reference
      const orderId = order.orderId;
      
      // Parse total amount (remove currency symbol and convert commas to periods)
      const totalAmount = this.parseAmount(order.orderTotal);
      
      // Process each item in the order
      for (const item of order.items) {
        // Parse item price
        const itemPrice = this.parseAmount(item.price);
        
        // Calculate item percentage of total order
        const itemPercentage = totalAmount > 0 ? (itemPrice / totalAmount) : 0;
        
        // Extract category from item title or use a default
        const category = this.extractCategoryFromTitle(item.title);
        
        // Create order item
        orderItems.push({
          name: item.title.substring(0, 50), // Truncate long titles
          description: `${item.title} - Order #${orderId} - Qty: ${item.qty}`,
          amount: itemPrice,
          date: orderDate,
          category: category,
          // Add additional useful information
          metadata: {
            orderTotal: totalAmount,
            orderId: orderId,
            itemPercentage: itemPercentage,
            deliveryStatus: order.deliveryStatus,
            orderUrl: order.url
          }
        });
      }
    }
    
    return orderItems;
  }
  /**
 * Parse amount from string (e.g. "â‚¬ 56,81" -> 56.81)
 */
private parseAmount(amountStr: string): number {
    if (!amountStr) return 0;
    
    // Remove currency symbols and spaces
    const cleanedStr = amountStr.replace(/[^\d,.-]/g, '');
    
    // Convert comma to period for decimal point
    const normalizedStr = cleanedStr.replace(',', '.');
    
    // Parse as float
    const amount = parseFloat(normalizedStr);
    
    // Return 0 if parsing failed
    return isNaN(amount) ? 0 : amount;
  }
  
  /**
   * Format date from various formats to YYYY-MM-DD
   */
  private formatDate(dateStr: string): string {
    if (!dateStr) return new Date().toISOString().split('T')[0];
    
    const months: { [key: string]: string } = {
      januari: '01',
      februari: '02',
      maart: '03',
      april: '04',
      mei: '05',
      juni: '06',
      juli: '07',
      augustus: '08',
      september: '09',
      oktober: '10',
      november: '11',
      december: '12'
    };
    
    // Common format in your data: "21 maart 2025"
    const dateParts = dateStr.trim().split(' ');
    if (dateParts.length === 3) {
      const day = dateParts[0].padStart(2, '0');
      const month = months[dateParts[1].toLowerCase()];
      const year = dateParts[2];
      
      if (month) {
        return `${year}-${month}-${day}`;
      }
    }
    
    // If format doesn't match, return original or current date
    console.warn(`Could not parse date: ${dateStr}`);
    return new Date().toISOString().split('T')[0];
  }
  
  /**
   * Extract a category from item title
   * You can customize this to match your preferred categories
   */
  private extractCategoryFromTitle(title: string): string {
    // Convert to lowercase for easier matching
    const lowerTitle = title.toLowerCase();
    
    // Try to determine category based on keywords in the title
    if (lowerTitle.includes('boek') || lowerTitle.includes('book')) return 'Books';
    if (lowerTitle.includes('kleding') || lowerTitle.includes('shirt') || lowerTitle.includes('broek') || lowerTitle.includes('henley') || lowerTitle.includes('trui')) return 'Clothing';
    if (lowerTitle.includes('elektronica') || lowerTitle.includes('usb') || lowerTitle.includes('cable') || lowerTitle.includes('adapter') || lowerTitle.includes('computer')) return 'Electronics';
    if (lowerTitle.includes('voedsel') || lowerTitle.includes('food') || lowerTitle.includes('snack')) return 'Groceries';
    if (lowerTitle.includes('speelgoed') || lowerTitle.includes('game') || lowerTitle.includes('toy')) return 'Entertainment';
    if (lowerTitle.includes('filter') || lowerTitle.includes('wasmiddel') || lowerTitle.includes('onderhoud')) return 'Household Supplies';
    if (lowerTitle.includes('gezondheid') || lowerTitle.includes('health') || lowerTitle.includes('beauty') || lowerTitle.includes('capsule')) return 'Health & Beauty';
    if (lowerTitle.includes('meubel') || lowerTitle.includes('furniture') || lowerTitle.includes('table') || lowerTitle.includes('lamp') || lowerTitle.includes('led')) return 'Home Improvement';
    if (lowerTitle.includes('huisdier') || lowerTitle.includes('pet') || lowerTitle.includes('kat') || lowerTitle.includes('hond')) return 'Pet Supplies';
    
    // Default category if no match
    return 'Shopping';
  }

  /**
 * Generate a report of matched and unmatched orders
 * This method should be called after findMatchingAmazonTransactions
 */
private generateOrderMatchingReport(
    orderTotals: Map<string, {date: string, orderId: string, total: number, items: OrderItem[]}>,
    matchedTransactions: {transaction: Transaction, transactionAccount: TransactionAccount, matchKey: string}[]
  ) {
    console.log("\n===== ORDER MATCHING REPORT =====");
  
    // Create a set of matched order keys for quick lookup
    const matchedOrderKeys = new Set<string>();
    for (const match of matchedTransactions) {
      matchedOrderKeys.add(match.matchKey);
    }
  
    // Count statistics
    let totalOrders = orderTotals.size;
    let matchedOrders = matchedOrderKeys.size;
    let unmatchedOrders = totalOrders - matchedOrders;
    
    // Print summary
    console.log(`SUMMARY:`);
    console.log(`- Total Orders: ${totalOrders}`);
    console.log(`- Matched Orders: ${matchedOrders} (${((matchedOrders/totalOrders)*100).toFixed(1)}%)`);
    console.log(`- Unmatched Orders: ${unmatchedOrders} (${((unmatchedOrders/totalOrders)*100).toFixed(1)}%)`);
    
    // Print matched orders
    console.log("\nMATCHED ORDERS:");
    let i = 1;
    for (const match of matchedTransactions) {
      const [date, orderId] = match.matchKey.split('_');
      const tx = match.transaction;
      console.log(`${i}. Order ${orderId} on ${date} - Amount: â‚¬${Math.abs(tx.amount).toFixed(2)} - Matched bank transaction ID: ${tx.id}`);
      i++;
    }
    
    // Print unmatched orders
    if (unmatchedOrders > 0) {
      console.log("\nUNMATCHED ORDERS:");
      i = 1;
      for (const [key, orderInfo] of orderTotals.entries()) {
        if (!matchedOrderKeys.has(key)) {
          console.log(`${i}. Order ${orderInfo.orderId} on ${orderInfo.date} - Amount: â‚¬${orderInfo.total.toFixed(2)} - Items: ${orderInfo.items.length}`);
          i++;
        }
      }
    }
    
    // If appropriate, provide some common reasons for unmatched orders
    if (unmatchedOrders > 0) {
      console.log("\nPOSSIBLE REASONS FOR UNMATCHED ORDERS:");
      console.log("1. The bank transaction is outside the date range being searched");
      console.log("2. The bank transaction amount differs from the order total (e.g., due to refunds or adjustments)");
      console.log("3. Multiple orders combined into a single bank transaction");
      console.log("4. Order was paid with a different payment method not included in the searched accounts");
      console.log("5. Order was cancelled or has not been charged yet");
    }
    
    console.log("===== END REPORT =====\n");
  }
}

// Example usage
if (require.main === module) {
    // This code runs when the file is executed directly (not imported)
    const updater = new PocketSmithUpdater({
        dryRun: true,
        splitExistingTransactions: true
    });

    // List all accounts if needed
    // updater.listAllAccounts()
    //   .then(() => console.log('Account listing complete'))
    //   .catch(error => console.error('Account listing failed:', error));

    // Process a CSV file
    updater.processCsvFile('orders_be.csv')
        .then(() => console.log('Processing complete'))
        .catch(error => console.error('Processing failed:', error));
}