import fs from 'fs';
import { PocketSmithClient, OrderItem, TransactionAccount, Transaction, PocketSmithApiError } from './PocketSmithClient';
import { parse as parseCsv } from 'papaparse';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

/**
 * CSV record structure (from your existing GenerateCSVToshlStrategy)
 */
interface CsvRecord {
  'Date': string;
  'Merchant': string;
  'Category': string;
  'Amount': string;
  'Currency': string;
  'Quantity': string;
  'Note': string;
  'Order Number': string;
  'Order Total': string;
}

/**
 * Options for the PocketSmith updater
 */
interface PocketSmithUpdaterOptions {
  apiKey?: string;
  transactionAccountId?: string;
  dryRun?: boolean;
  splitExistingTransactions?: boolean;
}

/**
 * A standalone class to sync Amazon order data from CSV to PocketSmith
 */
export class PocketSmithUpdater {
  private client: PocketSmithClient;
  private transactionAccountId: string;
  private dryRun: boolean;
  private splitExistingTransactions: boolean;

  /**
   * Create a new PocketSmith updater
   * @param options Configuration options
   */
  constructor(options: PocketSmithUpdaterOptions = {}) {
    // Initialize PocketSmith client
    this.client = new PocketSmithClient({
      apiKey: options.apiKey || process.env.POCKETSMITH_API_KEY || '',
    });
    
    // Set transaction account ID
    this.transactionAccountId = options.transactionAccountId || 
      process.env.POCKETSMITH_TRANSACTION_ACCOUNT_ID || '';
    
    // Set other options
    this.dryRun = options.dryRun ?? (process.env.POCKETSMITH_DRY_RUN === 'true');
    this.splitExistingTransactions = options.splitExistingTransactions ?? 
      (process.env.POCKETSMITH_SPLIT_TRANSACTIONS === 'true');
  }

  /**
   * Process a CSV file and sync with PocketSmith
   * @param csvFilePath Path to the CSV file generated by your existing strategy
   */
  async processCsvFile(csvFilePath: string): Promise<void> {
    try {
      console.log(`Processing CSV file: ${csvFilePath}`);
      
      // First validate that we can authenticate with PocketSmith
      const isAuthenticated = await this.client.validateAuthentication();
      if (!isAuthenticated) {
        console.error('Cannot proceed with PocketSmith integration due to authentication failure.');
        return;
      }
      
      // Check if file exists
      if (!fs.existsSync(csvFilePath)) {
        console.error(`CSV file not found: ${csvFilePath}`);
        return;
      }
      
      // Read and parse CSV file
      const csvContent = fs.readFileSync(csvFilePath, 'utf8');
      const parseResult = parseCsv<CsvRecord>(csvContent, {
        header: true,
        skipEmptyLines: true
      });
      
      if (parseResult.errors.length > 0) {
        console.error('CSV parsing errors:', parseResult.errors);
        return;
      }
      
      console.log(`Parsed ${parseResult.data.length} records from CSV`);
      
      // Convert CSV records to OrderItems
      const orderItems = this.convertCsvRecordsToOrderItems(parseResult.data);
      console.log(`Converted to ${orderItems.length} order items`);
      
      // If we want to split existing transactions
      if (this.splitExistingTransactions) {
        await this.splitExistingAmazonTransactions(orderItems);
      } else {
        // Otherwise, use the specified transaction account ID
        if (!this.transactionAccountId) {
          // Try to find the most recent Amazon transaction's account
          const mostRecent = await this.findMostRecentAmazonTransaction();
          
          if (mostRecent) {
            console.log(`Using most recent Amazon transaction's account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);
            await this.syncWithPocketSmith(orderItems, mostRecent.transactionAccount.id);
          } else {
            console.error('No Amazon transactions found and no transaction account ID specified in .env file.');
            console.error('Please set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.');
            return;
          }
        } else {
          console.log(`Using specified default transaction account ID: ${this.transactionAccountId}`);
          await this.syncWithPocketSmith(orderItems, this.transactionAccountId);
        }
      }
      
      console.log('PocketSmith processing completed successfully.');
      
    } catch (error) {
      if (error instanceof PocketSmithApiError) {
        // API errors are already properly formatted by the client
        console.error('Error processing CSV file:', error.message);
      } else {
        console.error('Error processing CSV file:', error instanceof Error ? error.message : String(error));
      }
    }
  }

  /**
   * Convert CSV records to OrderItems for PocketSmith API
   * @param records CSV records from your existing strategy
   * @returns OrderItems ready for PocketSmith API
   */
  private convertCsvRecordsToOrderItems(records: CsvRecord[]): OrderItem[] {
    return records.map(record => ({
      name: `${record.Merchant} - ${record.Category}`,
      description: record.Note,
      amount: parseFloat(record.Amount),
      date: record.Date,
      category: record.Category
    }));
  }

  /**
   * List all accounts and transaction accounts
   */
  async listAllAccounts(): Promise<void> {
    try {
      // First validate that we can authenticate with PocketSmith
      const isAuthenticated = await this.client.validateAuthentication();
      if (!isAuthenticated) {
        console.error('Cannot list accounts due to authentication failure.');
        return;
      }
      
      console.log("\n=== PocketSmith Accounts ===");
      
      const accounts = await this.client.getAllAccounts();
      console.log(`Found ${accounts.length} accounts:`);
      
      for (const account of accounts) {
        console.log(`\nðŸ“‚ Account: "${account.institution.title}" (ID: ${account.id})`);
        
        console.log('  Transaction Accounts:');
        for (const transactionAccount of account.transaction_accounts) {
          console.log(`  - ${transactionAccount.name} (ID: ${transactionAccount.id}, Type: ${transactionAccount.type})`);
        }
      }
      
      console.log("\nTo use a specific account, set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.");
      console.log("===========================\n");
      
    } catch (error) {
      if (error instanceof PocketSmithApiError) {
        console.error('Error listing accounts:', error.message);
      } else {
        console.error('Error listing accounts:', error instanceof Error ? error.message : String(error));
      }
    }
  }

  /**
   * Find the most recent Amazon transaction among all accounts
   */
  async findMostRecentAmazonTransaction(): Promise<{transaction: Transaction, transactionAccount: TransactionAccount} | null> {
    try {
      const amazonTransactions = await this.client.findAllAmazonTransactions();
      
      if (amazonTransactions.length === 0) {
        console.log("No Amazon transactions found");
        return null;
      }
      
      console.log(`Found ${amazonTransactions.length} Amazon transactions across all accounts`);
      
      // Sort by date descending to get the most recent
      const sortedTransactions = amazonTransactions.sort((a, b) => {
        return new Date(b.transaction.date).getTime() - new Date(a.transaction.date).getTime();
      });
      
      const mostRecent = sortedTransactions[0];
      
      console.log(`Most recent Amazon transaction found: ${mostRecent.transaction.payee} - $${mostRecent.transaction.amount} (${mostRecent.transaction.date})`);
      console.log(`In account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);
      
      return mostRecent;
    } catch (error) {
      console.error('Error finding recent Amazon transactions:', 
        error instanceof Error ? error.message : String(error));
      return null;
    }
  }

  /**
   * Find Amazon transactions that match order item dates
   * @param orderItems Order items with dates
   * @returns Map of transaction account IDs to lists of transactions
   */
  async findMatchingAmazonTransactions(orderItems: OrderItem[]): Promise<Map<number, {transactions: Transaction[], transactionAccount: TransactionAccount}>> {
    try {
      // Get the earliest date from the order items
      const startDate = this.getEarliestDate(orderItems);
      
      // Find all Amazon transactions since that date
      const amazonTransactions = await this.client.findAllAmazonTransactions(startDate);
      
      if (amazonTransactions.length === 0) {
        console.log(`No Amazon transactions found since ${startDate}`);
        return new Map();
      }
      
      console.log(`Found ${amazonTransactions.length} Amazon transactions across all accounts since ${startDate}`);
      
      // Extract all the dates from order items
      const orderDates = new Set(orderItems.map(item => item.date));
      
      // Filter transactions that match order item dates
      const matchingTransactions = amazonTransactions.filter(
        item => orderDates.has(item.transaction.date)
      );
      
      console.log(`Found ${matchingTransactions.length} transactions with matching dates`);
      
      // Group by transaction account ID
      const result = new Map<number, {transactions: Transaction[], transactionAccount: TransactionAccount}>();
      
      for (const item of matchingTransactions) {
        const accountId = item.transactionAccount.id;
        
        if (!result.has(accountId)) {
          result.set(accountId, {
            transactions: [],
            transactionAccount: item.transactionAccount
          });
        }
        
        result.get(accountId)!.transactions.push(item.transaction);
      }
      
      // Log the findings
      for (const [accountId, data] of result.entries()) {
        console.log(`Account ${data.transactionAccount.name} (ID: ${accountId}) has ${data.transactions.length} matching transactions`);
      }
      
      return result;
    } catch (error) {
      console.error('Error finding matching Amazon transactions:', 
        error instanceof Error ? error.message : String(error));
      return new Map();
    }
  }

  /**
   * Split existing Amazon transactions into individual items
   * @param orderItems Order items to create
   */
  async splitExistingAmazonTransactions(orderItems: OrderItem[]): Promise<void> {
    console.log("Looking for existing Amazon transactions to split...");
    
    try {
      // Group order items by date for easier matching
      const orderItemsByDate = this.groupOrderItemsByDate(orderItems);
      
      // Find matching Amazon transactions
      const matchingAccounts = await this.findMatchingAmazonTransactions(orderItems);
      
      if (matchingAccounts.size === 0) {
        console.log("No matching transactions found. Will use default transaction account instead.");
        
        if (!this.transactionAccountId) {
          // Try to find the most recent Amazon transaction's account
          const mostRecent = await this.findMostRecentAmazonTransaction();
          
          if (mostRecent) {
            console.log(`Using most recent Amazon transaction's account: ${mostRecent.transactionAccount.name} (ID: ${mostRecent.transactionAccount.id})`);
            await this.syncWithPocketSmith(orderItems, mostRecent.transactionAccount.id);
          } else {
            console.error('No Amazon transactions found and no transaction account ID specified in .env file.');
            console.error('Please set POCKETSMITH_TRANSACTION_ACCOUNT_ID in your .env file.');
          }
        } else {
          console.log(`Using specified default transaction account ID: ${this.transactionAccountId}`);
          await this.syncWithPocketSmith(orderItems, this.transactionAccountId);
        }
        
        return;
      }
      
      // Split transactions in each matching account
      let totalSplit = 0;
      let totalCreated = 0;
      
      for (const [accountId, data] of matchingAccounts.entries()) {
        const { transactions, transactionAccount } = data;
        
        console.log(`Processing ${transactions.length} transactions in account ${transactionAccount.name}...`);
        
        for (const transaction of transactions) {
          // Find matching order items for this transaction's date
          const date = transaction.date;
          const matchingItems = orderItemsByDate.get(date) || [];
          
          if (matchingItems.length === 0) {
            console.log(`No matching items found for transaction on ${date}, skipping`);
            continue;
          }
          
          console.log(`Splitting transaction ${transaction.id} (${transaction.payee}) into ${matchingItems.length} items`);
          
          // Split the transaction
          const result = await this.client.splitAmazonTransaction(
            transaction,
            transactionAccount,
            matchingItems,
            { dryRun: this.dryRun }
          );
          
          totalSplit += result.deleted;
          totalCreated += result.created;
        }
      }
      
      if (this.dryRun) {
        console.log(`DRY RUN: Would have split ${totalSplit} transactions into ${totalCreated} items`);
      } else {
        console.log(`Successfully split ${totalSplit} transactions into ${totalCreated} items`);
      }
    } catch (error) {
      console.error('Error splitting Amazon transactions:', 
        error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * Group order items by date
   * @param items Order items to group
   * @returns Map of dates to lists of order items
   */
  private groupOrderItemsByDate(items: OrderItem[]): Map<string, OrderItem[]> {
    const result = new Map<string, OrderItem[]>();
    
    for (const item of items) {
      if (!result.has(item.date)) {
        result.set(item.date, []);
      }
      
      result.get(item.date)!.push(item);
    }
    
    return result;
  }

  /**
   * Sync order items with PocketSmith
   * @param items Order items to sync
   */
  private async syncWithPocketSmith(items: OrderItem[], transactionAccountId: string | number): Promise<void> {
    try {
      console.log(`Syncing ${items.length} order items with PocketSmith account ${transactionAccountId}...`);
      
      // Use the PocketSmith client to process items
      const result = await this.client.processAmazonOrderItems(
        items,
        transactionAccountId,
        {
          deleteExisting: true,
          searchStartDate: this.getEarliestDate(items),
          dryRun: this.dryRun
        }
      );
      
      if (this.dryRun) {
        console.log(`DRY RUN: Would have deleted ${result.deleted} transactions and created ${result.created} transactions`);
      } else {
        console.log(`Successfully deleted ${result.deleted} transactions and created ${result.created} transactions in PocketSmith`);
      }
    } catch (error) {
      console.error('Error syncing with PocketSmith:', 
        error instanceof Error ? error.message : String(error));
      throw error; // Re-throw to be handled by the caller
    }
  }

  /**
   * Get the earliest date from a list of items
   * @param items Order items
   * @returns ISO date string
   */
  private getEarliestDate(items: OrderItem[]): string {
    if (items.length === 0) return new Date().toISOString().split('T')[0];
    
    const dates = items.map(item => new Date(item.date));
    const earliestDate = new Date(Math.min(...dates.map(d => d.getTime())));
    
    // Subtract 7 days to account for potential timing differences
    earliestDate.setDate(earliestDate.getDate() - 7);
    
    return earliestDate.toISOString().split('T')[0];
  }
}

// Example usage
if (require.main === module) {
  // This code runs when the file is executed directly (not imported)
  const updater = new PocketSmithUpdater({
    dryRun: true,
    splitExistingTransactions: true
  });
  
  // List all accounts if needed
  // updater.listAllAccounts()
  //   .then(() => console.log('Account listing complete'))
  //   .catch(error => console.error('Account listing failed:', error));
  
  // Process a CSV file
  updater.processCsvFile('orders_be.csv')
    .then(() => console.log('Processing complete'))
    .catch(error => console.error('Processing failed:', error));
}